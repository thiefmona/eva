# java

## redis

### 常用数据结构和应用场景

     string    缓存 计数器
     List      阻塞队列
     Hash      存储关系型数据表中记录
     Set       统计网站的独立ip
     Zset      带权重的队列 排行榜



### 缓存

- 穿透、击穿、雪崩

	- 穿透

	  查询一个不存在的数据 mysql查询不到数据也不会写入缓存 就会导致每次请求查询数据库
	  
		- 缓存空数据

		  查询返回的数据为空 仍然将这个空结果加入缓存
		  
		  优点 实现简单
		  缺点 消耗内存 可能会发生数据不一致的问题 (本来没有 后来数据库写入了)
		  
		- 布隆过滤器

		  优点 内存占用少 没有多余key
		  缺点 实现复杂 存在误判
		  
	- 击穿

	  给一个热点key设置了过期时间 当key过期的时候 恰好这个时间点正好有大量针对这个key的并发请求 可能瞬间压垮数据库
	  
		- 互斥锁

		  强一致 性能差
		  
		- 逻辑过期

		  高可用 性能好  高并发情况下不能保证数据绝对一致
		  
	- 雪崩

	  同一段时间大量key失效或者redis宕机 导致大量的请求到达数据库 导致数据库压力过大
	  
		- 给不同的key设置不同的过期时间

		- 利用Redis集群提高服务的高可用性

		- 给缓存业务添加降级策略

		- 给业务添加多级缓存

- redis和mysql数据一致性

  黑马 P05
  
	- 双写一致性

		- 延迟双删

		  延迟双删 如果是写操作 我们先把数据库中的数据删除 然后更新数据库 最后再延迟删除缓存中的数据 其中这个延迟多久不太好确定 再延迟的过程中可能会出现脏数据 并不能保证强一致性
		  
			- 允许延迟一致的业务

				- 采用异步通知

				  使用MQ中间件 更新数据后 通知缓存删除
				  利用canal中间件 不需要修改业务代码 伪装为mysql的一个从节点 canal通过读取binlog数据更新缓存
				  
			- 强一致性的业务

				- 采用Redisson提供的读写锁

				  共享锁 读锁readLock 加锁之后 其他线程可以共享读操作
				  排他锁 也叫独占锁writeLock 加锁之后 阻塞其他线程读写操作
				  
- 持久化

	- RDB

	  Redis DataBase Backup file(Redis数据备份文件) 也被叫做Redis数据快照 简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后 从磁盘读取文件 恢复数据
	  
	- AOF

	  Append Only File(追加文件) Redis处理的每一个写命令都会记录在AOF文件。可以看作是命令日志文件
	  
- 数据过期策略

  两种策略配合使用
  
	- 惰性删除

	  设置该key过期时间后 我们不去管他 当需要该key时 在检查key是否过期 如果过期 就删除他 反之 就返回该key
	  优点 对CPU友好 之会在使用该key时 才会进行过期检查 对于很多用不到的key不用浪费时间进行检查
	  缺点 对内存不友好 如果一个key已经过期 但是一直没有使用 那么该key就会一直存在内存中 内存永远不会释放
	  
	- 定期删除

	  每隔一段时间 对一些key进行检查 删除里面过期的key
	  优点 可以通过限制删除操作执行的时长和频率减少删除操作对cpu的影响 另外定期删除 可以有效释放过期键占用的内存
	  缺点 难以确定删除操作执行的时长和频率
	  slow模式 定时任务 可以修改rdis.config来调整频率
	  fast模式 执行频率不固定
	  
- 数据淘汰策略

  8种 重点后面三个
  
	- 默认 noeviction

	  不淘汰任何key 但是内存满了不允许写入新的数据
	  
	- LRU

	  Least Recently Used 最近最少使用
	  
	- LFU

	  Least Frequently Used 最少频率使用
	  
### 分布式锁

- setnx

	- Redis分布式锁如何合理的控制锁的有效时长

	  1 根据业务执行时间预估
	  2 给锁续期
	  
- redission

	- 看门狗

- 问题

	- redis分布式锁是如何实现的

	  先按照自己简历上的业务进行描述分布式锁的使用场景
	  我们使用的是基于redisson实现的分布式锁 底层是setnx命令和lua脚本(使用lua脚本用于保证原子性)
	  
	- redisson实现分布式锁如何合理的控制锁的有效时长

	  在redisson的分布式锁中 提供了一个watchDog看门狗机制 一个线程获取锁以后 wotchDog回归持有锁的线程续期 默认是10秒续期一次
	  
	- Redisson的分布式锁 是可以重入的吗

	  可以重入 多个锁重入需要判断是否是当前线程 在redis中进行存储的时候使用hash结构 来存储线程信息和重入次数
	  
	- Redisson锁能解决主从数据一致的问题吗

	  不能解决 但是可以使用Redisson提供的红锁来解决 但是这样的话 性能就太低了 如果业务中非要保证数据的强一致性 建议使用基于CP模型的zookeeper来实现分布式锁
	  
### 计数器

### 保存token

### 消息队列

### 延迟队列

### 集群

- 主从复制

	- 概念

	  单节点redis的并发能力是有上限的 要进一步提高redis的并发能力 就需要搭建主从集群 实现读写分离 一般都是一主多从 一般都是主节点负责写数据 从节点读数据
	  
	- 主从同步数据的流程

		- 全量同步

		  从节点请求主节点同步数据(replication id   offset)
		  主节点判断是否是第一次请求 是第一次就与从节点同步版本信息(replicaton id和offset)
		  主节点执行bgsave 生成rdb文件后 发送给从节点去执行
		  在rdb执行期间 主节点会以命令的方式记录到缓冲区(一个日志文件)
		  把生成之后的日志记录文件发送给从节点进行同步
		  
		- 增量同步

		  从节点请求主节点同步数据 主节点判断是不是第一次请求 不是第一次就获取从节点的offset值
		  主节点从命令日志文件中读取offset之后的值 发送给从节点进行数据同步
		  
- 哨兵模式

	- 作用

	  Redis提供了哨兵Sentinel机制来实现主从集群的自动故障恢复
	  监控 Sentinel会不断检查master和slave是否不断按预期工作
	  自动故障恢复 如果master故障 Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主
	  通知 Sentinel充当Redis客户端的服务发现来源 当集群发生故障转移时 会将最新消息推送给redis的客户端
	  
- 分片集群

  集群中多个master 每个master保存不同数据
  每个master都可以有多个slave节点
  master之间通过ping检测彼此健康状态
  客户端请求可以访问集群任意节点 最终都会转发到正确节点
  
	- redis分片集群中是数据是怎么存储和读取的

	  Redis分片集群引入哈希槽的概念 Redis集群有16384个哈希槽
	  将16384个哈希槽分配到不同的实例
	  读写数据 根据key的有效部分计算哈希值 对16384取余 余数作为插槽 寻找插槽所在的实例
	  
- 问题

	- 怎么保证Redis的高并发高可用

	  哨兵模式 实现主从集群的自动故障恢复(监控 自动故障恢复 通知)
	  
	- 你们使用Redis是单点还是集群，哪种集群

	  主从 一主一从 + 哨兵
	  
	- Reids集群脑裂怎么解决

	  有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没 能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在 old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会 
	  将old master降为salve，这时再从新master同步数据，这会导致old master中 的大量数据丢失。 
	  关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的salve 节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主 从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的 数据丢失
	  
### redis为什么这么快

Redis是纯内存操作 执行速度非常快
采用单线程 避免不必要的上下文切换可竞争条件 多线程还要考虑线程安全问题
使用I/O多路复用模型 非阻塞IO

## mysql

### 慢查询

- 如何定位慢查询

  介绍一下当时产生问题的场景 比如：我们当时的一个接口测试的时候非常慢 压测的结果是大概5秒钟
  我们系统中当时采用了运维工具 SkyWalking 可以监测出哪个接口 最终因为是Sql的问题
  在mysql中开启了慢日志查询 设置的值是2秒 一旦sql执行超过两秒就会记录到日志中(调试阶段 生产环境没开启慢日志 影响mysql性能)
  
- 如何分析慢查询SQL

  可以使用MySql自带的分析工具Explain
  通过key和key_len检查是否命中了索引(索引本身存在是否有失效的情况)
  通过type字段查看sql是否有进一步的优化空间 是否存在全索引扫描或者全盘扫描
  通过extra建议判断 是否出现了回表的情况 如果出现了 可以尝试添加索引或修改返回字段来修复
  
### 索引

## SpringBoot

### SpringBoot自动配置原理

通过@SpringBootConfiguration引入了@EnableAutoConfiguration(负责启动自动配置功能)
@EnableAutoConfiguration引入了@Import注解
Spring容器启动时 加载IOC容器时 会解析@Import注解
@Import注解导入了AutoConfigurationImportSelector继承deferedImportSelector(这个会使SpringBoot的自动配置类的加载顺序放在最后 便于自定义扩展和覆盖)
然后读取出META-INF/Spring.factories文件
过滤出所有的AutoConfigurationClass类型的类
最后通过@Condition排除出无效的配置类

